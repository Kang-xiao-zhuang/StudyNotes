# Java正则表达式

**写在前面**

**学习地址：**

**[【韩顺平讲Java】Java 正则表达式专题 ](https://www.bilibili.com/video/BV1Eq4y1E79W?p=1)**

**[Java 正则表达式 | 菜鸟教程 (runoob.com)](https://www.runoob.com/java/java-regular-expressions.html)**

**感谢韩老师的讲解视频，十分感谢！！！**

# 1. 认识正则表达式

首先通过一个例子来体验正则表达式的威力

**随便找段话，找出所有4个连续数字的式子**

```java
package com.zhuang.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @Classname Regex01
 * @Description 体验正则表达式的威力
 * @Date 2021/5/23 12:58
 * @Created by dell
 */

public class Regex01 {
    public static void main(String[] args) {
        String content = "1998 年 12 月 8 日，第二代 Java 平台的企业版 J2EE 发布。1999 年 6 月，Sun 公司发布了" +
                "第二代 Java 平台（简称为 Java2）的 3 个版本：J2ME（Java2 Micro Edition，Java2 平台的微型" +
                "版），应用于移动、无线及有限资源的环境；J2SE（Java 2 Standard Edition，Java 2 平台的" +
                "标准版），应用于桌面环境；J2EE（Java 2Enterprise Edition，Java 2 平台的企业版），应" +
                "用 3443 于基于 Java 的应用服务器。Java 2 平台的发布，是 Java 发展过程中最重要的一个" +
                "里程碑，标志着 Java 的应用开始普及 9889 ";
        
        //目标匹配所有四个数字
        // \\d表示任意一个数字
        String regStr="\\d\\d\\d\\d";
        // 创建模式对象 即 正则表达式对象
        Pattern pattern = Pattern.compile(regStr);
        // 创建匹配器 按照正则表达式的规则去匹配content字符串
        Matcher matcher = pattern.matcher(content);

        matcher.find();
        while (matcher.find()){
            System.out.println("找到->"+matcher.group(0));
        }
    }
}
```

结果

![](https://gitee.com/zhuang-kang/note-picture-2/raw/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%BE%E7%89%87/Snipaste_2021-05-23_13-08-55.png)

通过几个式子，就可以精确的找到连续的四个数字！

接下来分析两个重要的表达式

- **matcher.find();**

作用：考虑分组

什么是分组？ 比如(\\\d)(\\\d) 表达式中有()表示分组，第一个()表示第1组，第二表示第2组

1. 根据指定的规则，定位满足规则的子字符串 比如(20)(66)
2. 找到后，将 **子字符串的开始索引记录到matcher对象的属性**  int[] groups；

- 2.1 groups[0] = 0 , 把该子字符串的结束的索引+1 的值记录到 groups[1] = 4 
- 2.2 记录 1 组()匹配到的字符串 groups[2] = 0 groups[3] = 2 
- 2.3 记录 2 组()匹配到的字符串 groups[4] = 2 groups[5] = 4
- 2.4.如果有更多的分组.....

3. 同时记录oldLast的值 子字符串的结束的 索引+1的值即 35 下次执行find时，就从35开始匹配



- **matcher.group();**

先看源码

```java
public String group(int group) {
        if (first < 0)
            throw new IllegalStateException("No match found");
        if (group < 0 || group > groupCount())
            throw new IndexOutOfBoundsException("No group " + group);
        if ((groups[group*2] == -1) || (groups[group*2+1] == -1))
            return null;
        return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString();
    }
```

- 根据 groups[0]=31 和 groups[1]=35 的记录的位置，从 content 开始截取子字符串返回 

- 就是 [31,35) 包含 31 但是不包含索引为 35 的位置 

- 如果再次指向 find 方法.仍然按照上面分析来执行



我们将原来的代码修改下 看看分组的匹配情况

将 `String regStr="\\d\\d\\d\\d";` 改为`String regStr="(\\d\\d)(\\d\\d)";`

**debug启动** 断点位置如下

![](https://gitee.com/zhuang-kang/note-picture-2/raw/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%BE%E7%89%87/Snipaste_2021-05-23_13-30-55.png)

```java
package com.zhuang.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @Classname Regex01
 * @Description 体验正则表达式的威力
 * @Date 2021/5/23 12:58
 * @Created by dell
 */

public class Regex01 {
    public static void main(String[] args) {
        String content = "1998 年 12 月 8 日，第二代 Java 平台的企业版 J2EE 发布。1999 年 6 月，Sun 公司发布了" +
                "第二代 Java 平台（简称为 Java2）的 3 个版本：J2ME（Java2 Micro Edition，Java2 平台的微型" +
                "版），应用于移动、无线及有限资源的环境；J2SE（Java 2 Standard Edition，Java 2 平台的" +
                "标准版），应用于桌面环境；J2EE（Java 2Enterprise Edition，Java 2 平台的企业版），应" +
                "用 3443 于基于 Java 的应用服务器。Java 2 平台的发布，是 Java 发展过程中最重要的一个" +
                "里程碑，标志着 Java 的应用开始普及 9889 ";
        
        //目标匹配所有四个数字
        // \\d表示任意一个数字
        String regStr="(\\d\\d)(\\d\\d)";
        // 创建模式对象 即 正则表达式对象
        Pattern pattern = Pattern.compile(regStr);
        // 创建匹配器 按照正则表达式的规则去匹配content字符串
        Matcher matcher = pattern.matcher(content);

        matcher.find();
        while (matcher.find()){
            System.out.println("找到->"+matcher.group(0));
            System.out.println("第一组找到的值->"+matcher.group(1));
            System.out.println("第二组找到的值->"+matcher.group(2));
        }
    }
}
```

启动后进入方法查看属性  **看到groups中的索引元素在增加！**

![](https://gitee.com/zhuang-kang/note-picture-2/raw/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%BE%E7%89%87/Snipaste_2021-05-23_13-29-17.png)

**小结**

1. 如果正则表达式有() 即分组 

2. 取出匹配的字符串规则如下 

3. group(0) 表示匹配到的子字符串 

4. group(1) 表示匹配到的子字符串的第一组字串 

5. group(2) 表示匹配到的子字符串的第 2 组字串 
6.  但是分组的数不能越界



# 2. 正则表达式介绍

正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为"元字符"）。

正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。

元字符从功能上大概分为

- 限定符
- 选择匹配符
- 分组组合和反向引用符
- 特殊字符
- 字符匹配符
- 定位符

## 2.1 元字符-转义号\\\

`\\`符号 说明：我们使用正则表达式检索某些特殊的字符的时候，需要用到转义符号，否则检索不到结果

<font color="red">注意：Java的正则表达式中，两个`\\`代表其他语言中的一个`\`</font>

```java
package com.zhuang.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @Classname Regex02
 * @Description 演示转义字符的使用
 * @Date 2021/5/23 13:37
 * @Created by dell
 */

public class Regex02 {
    public static void main(String[] args) {
        String content = "abc$(a.bc(123( )";
        //匹配( => \\(
        //匹配. => \\. //String regStr = "\\.";
        //String regStr = "\\d\\d\\d";
        String regStr = "\\d{3}";
        Pattern pattern = Pattern.compile(regStr);
        Matcher matcher = pattern.matcher(content);
        while (matcher.find()) {
            System.out.println("找到 " + matcher.group(0));
        }
    }
}
```

其中 

```java
String regStr = "\\d\\d\\d";//可以写成下面的方式
String regStr = "\\d{3}";
```

![](https://gitee.com/zhuang-kang/note-picture-2/raw/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%BE%E7%89%87/Snipaste_2021-05-23_13-43-52.png)

![](https://gitee.com/zhuang-kang/note-picture-2/raw/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%BE%E7%89%87/Snipaste_2021-05-23_13-44-19.png)



## 2.2 元字符-字符匹配符

![](https://gitee.com/zhuang-kang/note-picture-2/raw/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%BE%E7%89%87/Snipaste_2021-05-23_16-51-49.png)

![](https://gitee.com/zhuang-kang/note-picture-2/raw/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%BE%E7%89%87/Snipaste_2021-05-23_16-52-17.png)

```java
package com.zhuang.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @Classname Regex03
 * @Description 演示转义字符的使用
 * @Date 2021/5/23 13:58
 * @Created by dell
 */

public class Regex03 {
    public static void main(String[] args) {
        String content = "a11c8abc _ABCy @";
        String regStr = "[a-z]";//匹配 a-z 之间任意一个字符
        //String regStr = "[A-Z]";//匹配 A-Z 之间任意一个字符
        //String regStr = "abc";//匹配 abc 字符串[默认区分大小写]
        //String regStr = "(?i)abc";//匹配 abc 字符串[不区分大小写
        //String regStr = "[0-9]";//匹配 0-9 之间任意一个字符
        //String regStr = "[^a-z]";//匹配 不在 a-z 之间任意一个字符
        //String regStr = "[^0-9]";//匹配 不在 0-9 之间任意一个字符
        //String regStr = "[abcd]";//匹配 在 abcd 中任意一个字符
        //String regStr = "\\D";//匹配 不在 0-9 的任意一个字符
        //String regStr = "\\w";//匹配 大小写英文字母, 数字，下划线
        //String regStr = "\\W";//匹配 等价于 [^a-zA-Z0-9_]
        //\\s 匹配任何空白字符(空格,制表符等)
        //String regStr = "\\s";
        //\\S 匹配任何非空白字符 ,和\\s 刚好相反
        //String regStr = "\\S";
        //. 匹配出 \n 之外的所有字符,如果要匹配.本身则需要使用 \\. 
        // String regStr = ".";
        //说明
        //1. 当创建 Pattern 对象时，指定 Pattern.CASE_INSENSITIVE, 表示匹配是不区分字母大小写.
        Pattern pattern = Pattern.compile(regStr/*, Pattern.CASE_INSENSITIVE*/);
        Matcher matcher = pattern.matcher(content);
        while (matcher.find()) {
            System.out.println("找到 " + matcher.group(0));
        }
    }
}
```



## 2.3 元字符-选择匹配字符

在匹配某个字符串的时候是选择性的 既可以匹配这个，也可以匹配那个，需要用到匹配符号`|`

| 符号 | 符号                       | 示例   | 解释     |
| ---- | -------------------------- | ------ | -------- |
| \|   | 匹配"\|"之前或之后的表达式 | ab\|cd | ab或者cd |

```java
package com.zhuang.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @Classname Regex04
 * @Description 选择匹配符
 * @Date 2021/5/23 14:04
 * @Created by dell
 */

public class Regex04 {
    public static void main(String[] args) {
        String content = "kangxiaozhuang 康 扛抗";
        String regStr = "kang|康|扛";
        Pattern pattern = Pattern.compile(regStr/*, Pattern.CASE_INSENSITIVE*/);
        Matcher matcher =pattern.matcher(content);
        while (matcher.find()) {
            System.out.println("找到 " + matcher.group(0));
        }
    }
}
```

![](https://gitee.com/zhuang-kang/note-picture-2/raw/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%BE%E7%89%87/Snipaste_2021-05-23_14-06-12.png)



## 2.4 元字符-限定符

用于指定其前面的字符和组合项连续出现多少次

![](https://gitee.com/zhuang-kang/note-picture-2/raw/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%BE%E7%89%87/Snipaste_2021-05-23_16-52-55.png)

```java
package com.zhuang.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @Classname Regex05
 * @Description 用一句话描述类的作用
 * @Date 2021/5/23 14:15
 * @Created by dell
 */

public class Regex05 {
    public static void main(String[] args) {
        String content = "a211111aaaaaahello";
        //a{3},1{4},\\d{2}
        //String regStr = "a{3}";// 表示匹配 aaa
        //String regStr = "1{4}";// 表示匹配 1111
        //String regStr = "\\d{2}";// 表示匹配 两位的任意数字字符
        //a{3,4},1{4,5},\\d{2,5}
        //细节：java 匹配默认贪婪匹配，即尽可能匹配多的
        //String regStr = "a{3,4}"; //表示匹配 aaa 或者 aaaa
        //String regStr = "1{4,5}"; //表示匹配 1111 或者 11111
        //String regStr = "\\d{2,5}"; //匹配 2 位数或者 3,4,5
        //1+
        //String regStr = "1+"; //匹配一个 1 或者多个 1
        //String regStr = "\\d+"; //匹配一个数字或者多个数字
        //String regStr = "1*"; //匹配 0 个 1 或者多个 1
        //演示?的使用, 遵守贪婪匹配
        String regStr = "a1?"; //匹配 a 或者 a1
        Pattern pattern = Pattern.compile(regStr/*, Pattern.CASE_INSENSITIVE*/);
        Matcher matcher = pattern.matcher(content);
        while (matcher.find()) {
            System.out.println("找到 " + matcher.group(0));
        }
    }
}
```



## 2.5 元字符-定位符

定位符，规定要匹配的字符串出现的位置，比如在字符串的开始还是在结束的位置

| 符号 | 含义                   | 示例                 | 说明                                                         | 匹配输入       |
| ---- | ---------------------- | -------------------- | ------------------------------------------------------------ | -------------- |
| ^    | 指定起始字符           | `^[0-9]+[a-z]*`      | 以至少1个数字开头，后接任意个小写字母的字符串                | 123,6aa        |
| $    | 指定结束字符           | `^[0-9]\\\\-[a-z]+$` | 以1个数字开头后连接字符"-"，并以至少1个小写字母结尾的字符串  | 1-a            |
| \\\b | 匹配目标字符串的边界   | kang\\\b             | 这里说的字符串的边界指的是子串间有空格，或者是目标字符串的结束位置 | spkang,hhkang  |
| \\\B | 匹配目标字符串的非边界 | kang\\\B             | 和\\\b的含义刚刚相反                                         | kangzk,niukang |

```java
package com.zhuang.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @Classname Regex06
 * @Description 演示定位符的使用
 * @Date 2021/5/23 14:24
 * @Created by dell
 */

public class Regex06 {
    public static void main(String[] args) {
        String content = "kangxiaozhuang spkang nnkang";
    //String content = "123-abc";
    //以至少 1 个数字开头，后接任意个小写字母的字符串
    //String regStr = "^[0-9]+[a-z]*";
    //以至少 1 个数字开头, 必须以至少一个小写字母结束
    //String regStr = "^[0-9]+\\-[a-z]+$";
    //表示匹配边界的 han[这里的边界是指：被匹配的字符串最后, // 也可以是空格的子字符串的后面]
    String regStr = "kang\\b";
    //和\\b 的含义刚刚相反
//        String regStr = "kang\\B";
        Pattern pattern = Pattern.compile(regStr);
        Matcher matcher = pattern.matcher(content);
        while (matcher.find()) {
            System.out.println("找到=" + matcher.group(0));
        }
    }
}
```



# 3. 分组

![](https://gitee.com/zhuang-kang/note-picture-2/raw/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%BE%E7%89%87/Snipaste_2021-05-23_16-54-39.png)

![](https://gitee.com/zhuang-kang/note-picture-2/raw/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%BE%E7%89%87/Snipaste_2021-05-23_16-54-37.png)

```java
package com.zhuang.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @Classname Regex07
 * @Description 分组演示
 * @Date 2021/5/23 14:34
 * @Created by dell
 */

public class Regex07 {
    public static void main(String[] args) {

        String content = "kangxiaozhuang s7789 nn1189h";
        // 1. matcher.group(0) 得到匹配到的字符串
        // 2. matcher.group(1) 得到匹配到的字符串的第 1 个分组内容
        // 3. matcher.group(2) 得到匹配到的字符串的第 2 个分组内容
        //String regStr = "(\\d\\d)(\\d\\d)";//匹配 4 个数字的字符串
        //命名分组： 即可以给分组取名
        String regStr = "(?<g1>\\d\\d)(?<g2>\\d\\d)";//匹配 4 个数字的字符串
        Pattern pattern = Pattern.compile(regStr);
        Matcher matcher = pattern.matcher(content);
        while (matcher.find()) {
            System.out.println("找到=" + matcher.group(0));
            System.out.println("第 1 个分组内容=" + matcher.group(1));
            System.out.println("第 1 个分组内容[通过组名]=" + matcher.group("g1"));
            System.out.println("第 2 个分组内容=" + matcher.group(2));
            System.out.println("第 2 个分组内容[通过组名]=" + matcher.group("g2"));
        }
    }
}
```

![](https://gitee.com/zhuang-kang/note-picture-2/raw/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%BE%E7%89%87/Snipaste_2021-05-23_14-35-48.png)

# 4. 练习

![](https://gitee.com/zhuang-kang/note-picture-2/raw/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%BE%E7%89%87/Snipaste_2021-05-23_14-37-53.png)

要求如上 对字符串进行验证！

注意 汉字的编码如下范围

```java
String regStr = "^[\u0391-\uffe5]+$";
```

示例

```java
package com.zhuang.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @Classname Regex08
 * @Description 应用实例
 * @Date 2021/5/23 14:39
 * @Created by dell
 */

public class Regex08 {
    public static void main(String[] args) {
        String content = "13588889999";
        // 汉字
        //String regStr = "^[\u0391-\uffe5]+$";
        // 邮政编码
        // 要求：是 1-9 开头的一个六位数. 比如：123890
        //  String regStr = "^[1-9]\\d{5}$";
        // QQ 号码
        // 要求: 是 1-9 开头的一个(5 位数-10 位数) 比如: 12389 , 1345687 , 187698765
        //String regStr = "^[1-9]\\d{4,9}$";
        // 手机号码
        // 要求: 必须以 13,14,15,18 开头的 11 位数 , 比如 13588889999
        String regStr = "^1[3|4|5|8]\\d{9}$";
        Pattern pattern = Pattern.compile(regStr);
        Matcher matcher = pattern.matcher(content);
        if(matcher.find()) {
            System.out.println("满足格式");
        } else {
            System.out.println("不满足格式");
        }
    }
}
```

**匹配URL的思路**

- 先确定 url 的开始部分 https:// | http://
- 然后通过 ([\w-]+\.)+[\w-]+ 匹配` www.bilibili.com `
- /video/BV1fh411y7R8?from=sear 匹配(\/[\w-?=&/%.#]*)?

```java
package com.zhuang.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @author dell
 * @Classname Regex09
 * @Description 判断URL的表达式
 * @Date 2021/5/23 14:42
 * @Created by dell
 */

public class Regex09 {
    public static void main(String[] args) {
        //String content = "https://www.bilibili.com/video/BV1fh411y7R8?from=search&seid=1831060912083761326";
        String content ="https://www.runoob.com/regexp/regexp-syntax.html";
        //注意：[. ? *]表示匹配就是.本身
        String regStr = "^((http|https)://)?([\\w-]+\\.)+[\\w-]+(\\/[\\w-?=&/%.#]*)?$";
        Pattern pattern = Pattern.compile(regStr);
        Matcher matcher = pattern.matcher(content);
        if(matcher.find()) {
            System.out.println("满足格式");
        } else {
            System.out.println("不满足格式");
        }
        //这里如果使用 Pattern 的 matches 整体匹配 比较简洁
        System.out.println(Pattern.matches(regStr, content));//
    }
}
```



# 5. 正则表达式常用的三个常用类

![](https://gitee.com/zhuang-kang/note-picture-2/raw/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%BE%E7%89%87/Snipaste_2021-05-23_14-48-48.png)

更多方法参考：[Java 正则表达式 | 菜鸟教程 (runoob.com)](https://www.runoob.com/java/java-regular-expressions.html)

```java
package com.zhuang.regex;

import java.util.regex.Pattern;

/**
 * @Classname PatternMethod
 * @Description 演示 matches 方法，用于整体匹配, 在验证输入的字符串是否满足条件使用
 * @Date 2021/5/23 14:49
 * @Created by dell
 */

public class PatternMethod {
    public static void main(String[] args) {
        String content = "hello abc hello, kang";
        //String regStr = "hello";
        String regStr = "hello.*";
        boolean matches = Pattern.matches(regStr, content);
        System.out.println("整体匹配= " + matches);
    }
}
```

- Matcher类

```java
package com.zhuang.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @Classname MatcherMethod
 * @Description  Matcher常用方法
 * @Date 2021/5/23 14:51
 * @Created by dell
 */

public class MatcherMethod {
    public static void main(String[] args) {
        String content = "hello edu jack kangxiaohhh hello hhkxz hello kkxxaa kxzkxz";
        String regStr = "hello";
        Pattern pattern = Pattern.compile(regStr);
        Matcher matcher = pattern.matcher(content);
        while (matcher.find()) {
            System.out.println("=================");
            System.out.println(matcher.start());
            System.out.println(matcher.end());
            System.out.println("找到: " + content.substring(matcher.start(), matcher.end()));
        }
        //整体匹配方法，常用于，去校验某个字符串是否满足某个规则
        System.out.println("整体匹配=" + matcher.matches());
        //完成如果 content 有 kang 替换成 康小庄！！！
        regStr = "kang";
        pattern = Pattern.compile(regStr);
        matcher = pattern.matcher(content);
        //注意：返回的字符串才是替换后的字符串 原来的 content 不变化
        String newContent = matcher.replaceAll("康小庄！！！");
        System.out.println("newContent=" + newContent);
        System.out.println("content=" + content);
    }
}
```

![](https://gitee.com/zhuang-kang/note-picture-2/raw/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%BE%E7%89%87/Snipaste_2021-05-23_14-55-34.png)



# 6.分组，捕获，反向引用

**分组**

- 可以用圆括号组成一个比较复杂的匹配模式，那么一个圆括号的部分我们可以看做是一个子表达式/一个分组

**捕获**

- 把正则表达式中子表达式/分组匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用，从左向右，以分组的左括号为标志，第一个出现的分组的组好为1，第二个位2，以此类推，组0代表的是整个正则式

**反向引用**

- 圆括号的内容被捕获后，可以在这个括号后使用，写出一个实用的匹配模式 **称为反向引用** 可以在表达式内部或者外部
- 内部反向引用**\\\分组号**，外部反向引用的**$分组号**

看几个案例

- 要匹配两个连续的相同数字  `(\\d)\\1`
- 要匹配五个连续的相同数字 `(\\d)\\1{4}`
- 要匹配个位与千位相同，十位与百位相同的数，5225,1551  `(\\d)(\\d)\\2\\1`
- 匹配 形如12321-333666999 这样的号码满足前面一个五位数
   然后一个- 然后是一个九位数，连续的每三位要相同

```java
package com.zhuang.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @Classname Regex10
 * @Description 案例
 * @Date 2021/5/23 15:26
 * @Created by dell
 */

public class Regex10 {
    public static void main(String[] args) {
        String content="h23423288888856666 jackangdaxxxiiit6886  65432-999888777";
        // 匹配连续两个相同的数字
       // String regStr="(\\d)\\1";
       // 匹配连续五个相同的数字
       // String regStr="(\\d)\\1{4}";
       //匹配 个位和千位相同 十位和百位相同的数字
       //   String regStr="(\\d)(\\d)\\2\\1";
        // 匹配 形如12321-333666999 这样的号码满足前面一个五位数
//        然后一个- 然后是一个九位数，连续的每三位要相同
        String regStr="\\d{5}-(\\d)\\1{2}(\\d)\\2{2}(\\d)\\3{2}";
       Pattern pattern = Pattern.compile(regStr);
        Matcher matcher = pattern.matcher(content);
        while (matcher.find()){
            System.out.println("找到->"+matcher.group(0));
        }
    }
}
```

# 7.String 类中使用正则表达

替换功能

 StringReg.java String 类

- public String replaceAll(String regex,String replacement)

 判断功能 

String 类 

- public boolean matches(String regex){} //使用 Pattern 和 Matcher 类 

分割功能 

String 类 

- public String[] split(String regex)

```java
package com.zhuang.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @Classname Regex11
 * @Description String类中的方法
 * @Date 2021/5/23 15:39
 * @Created by dell
 */

public class Regex11 {
    public static void main(String[] args) {
        String content = "2000 年 5 月，JDK1.3、JDK1.4 和 J2SE1.3 相继发布，几周后其" +
                "获得了 Apple 公司 Mac OS X 的工业标准的支持。2001 年 9 月 24 日，J2EE1.3 发" +
                "布。" +
                "2002 年 2 月 26 日，J2SE1.4 发布。自此 Java 的计算能力有了大幅提升";
//使用正则表达式方式，将 JDK1.3 和 JDK1.4 替换成 JDK
        content = content.replaceAll("JDK1\\.3|JDK1\\.4", "JDK");
        System.out.println(content);
//要求 验证一个 手机号， 要求必须是以 138 139 开头的
        content = "13888889999";
        if (content.matches("1(38|39)\\d{8}")) {
            System.out.println("验证成功");
        } else {
            System.out.println("验证失败");
        }
        //要求按照 # 或者 - 或者 ~ 或者 数字 来分割
        System.out.println("===================");
        content = "hello#abc-jack12smith~北京";
        String[] split = content.split("#|-|~|\\d+");
        for (String s : split) {
            System.out.println(s);
        }
    }
}
```

# 8. 综合练习

## 8.1 验证电子邮件格式是否合法

- 只能有一个@
- @前面是用户名，可以是a-z，A-Z，0-9 - _ 字符
- @后面是域名 并且域名只能是英文字母 比如 `itkxz@qq.com`

- 写出对应的正则表达式验证输入的字符串是否满足规则

> 先写出简单的表达式，再逐步完善！

```java
package com.zhuang.regex;

/**
 * @Classname Homework01
 * @Description 案例1
 * @Date 2021/5/23 16:08
 * @Created by dell
 */

public class Homework01 {
    public static void main(String[] args) {
        String content="itkxz@qq.com";
        String regStr="[\\w-_]+@([a-zA-Z]+\\.)+[a-zA-Z]+";

        if (content.matches(regStr)){
            System.out.println("匹配成功！！！");
        }else {
            System.out.println("匹配失败！！！");
        }
    }
}
```

## 8.2 验证是不是整数或小数

- 考虑到正数和负数
- 123 34.55 0.58等

```java
package com.zhuang.regex;

/**
 * @Classname Homework01
 * @Description 案例2
 * @Date 2021/5/23 16:08
 * @Created by dell
 */

public class Homework02 {
    public static void main(String[] args) {
        String content="-0.58";
        String regStr="^[+-]?([1-9]\\d*|0)(\\.\\d+)?$";

        if (content.matches(regStr)){
            System.out.println("匹配成功 是正数或者小数！！！");
        }else {
            System.out.println("匹配失败！！！");
        }
    }
}
```

## 8.3 验证是否为URL

- 协议
- 域名
- 端口
- 文件名

```java
package com.zhuang.regex;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @Classname Homework03
 * @Description 案例3
 * @Date 2021/5/23 16:08
 * @Created by dell
 */

public class Homework03 {
    public static void main(String[] args) {
        String content="http://space.bilibili.com:8080/abc/favlist";
        String regStr="^([a-zA-Z]+)://([a-zA-Z.]+):(\\d+)[\\w-/]*/([\\w.]+)$";

        Pattern pattern = Pattern.compile(regStr);
        Matcher matcher = pattern.matcher(content);

        if (matcher.matches()){
            System.out.println("匹配成功！！！");
            System.out.println("协议->"+ matcher.group(0));
            System.out.println("域名->"+ matcher.group(1));
            System.out.println("端口->"+ matcher.group(2));
            System.out.println("文件名->"+ matcher.group(3));
        }else {
            System.out.println("匹配失败！！！");
        }
    }
}
```

![](https://gitee.com/zhuang-kang/note-picture-2/raw/master/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9B%BE%E7%89%87/Snipaste_2021-05-23_16-37-48.png)



**写在最后：用韩老师的一句话来鞭策自己"我亦无他，惟手熟尔！"**



**若有错误，还请各位指出错误，及时更改！**

