# 1. 冒泡排序(Bubble Sort)

## 1.1 概念

冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

## 1.2 算法描述

1. 比较相邻两个元素，如果第一个比第二个大，就交换位置
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，最后的元素就是最大的数
3. 针对所有的元素重复以上的步骤，除了最后一个
4. 重复步骤1~3，直到排序完成

**示意图**

![](https://pic.imgdb.cn/item/60c606fb844ef46bb29586b9.gif)

## 1.3 代码演示

```java
package com.zhuang.algorithm;

/**
 * @Classname BubbleSort
 * @Description 冒泡排序
 * @Date 2021/6/13 14:04
 * @Created by dell
 */

public class BubbleSort {
    public static void main(String[] args) {
        int[] arr =new int[]{0,5,6,1,8,2};
        bubbleSort(arr);
        System.out.println(Arrays.toString(arr));//[0, 1, 2, 5, 6, 8]
    }
    public static void bubbleSort(int[] arr) {
        int temp=0;
        if (arr.length == 0) {
            return;
        }
        //每次需要排序的长度
        for(int i=arr.length - 1; i >= 0; i--){
            //从第一个元素到第i个元素
            for (int j = 0; j < i; j++) {
                if (arr[j]>arr[j+1]){
                    temp = arr[j];
                    arr[j]=arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }
    }
}
```

## 1.4 算法分析

- 最佳情况：T(n) = O(n)
- 最差情况：T(n) = O(n^2^)
- 平均情况：T(n) = O(n^2^)

## 1.5 稳定性

在相邻元素相等时，它们并不会交换位置，所以，冒泡排序是稳定排序。

## 1.6 适用场景

冒泡排序思路简单，代码也简单，特别适合小数据的排序。但是，由于算法复杂度较高，在数据量大的时候不适合使用。



# 2. 选择排序(Selection Sort)

## 2.1 概念

选择排序 是表现最稳定的排序算法之一 ，因为无论什么数据进去都是O(n^2^)的时间复杂度 ，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。

选择排序(Selection-sort) 是一种简单直观的排序算法。

## 2.2 算法描述

它的工作原理：

- 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置

- 然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。

- 以此类推，直到所有元素均排序完毕。

**示意图**

[![](https://pic.imgdb.cn/item/60c5a8fa844ef46bb29f792b.gif)](https://pic.imgdb.cn/item/60c5a8fa844ef46bb29f792b.gif)

## 2.3 代码演示

```java
package com.zhuang.algorithm;

/**
 * @Classname SelectionSort
 * @Description 选择排序
 * @Date 2021/6/13 14:44
 * @Created by dell
 */

public class SelectionSort {
    public static void main(String[] args) {
        int[] arr =new int[]{0,5,6,1,8,2};
        selectionSort(arr);
       	System.out.println(Arrays.toString(arr));//[0, 1, 2, 5, 6, 8]
    }
    public static void selectionSort(int[] arr){
        int temp,min=0;
        for (int i = 0; i < arr.length-1; i++) {
            min=i;
            //循环查找最小值
            for (int j = i+1; j < arr.length; j++) {
                if (arr[min]>arr[j]) {
                    min = j;
                }
            }
            if (min!=i){
                temp=arr[i];
                arr[i] = arr[min];
                arr[min] = temp;
            }
        }
    }
}
```

## 2.4 算法分析

- 最佳情况：T(n) = O(n^2^)
- 最差情况：T(n) = O(n^2^)
- 平均情况：T(n) = O(n^2^)

## 2.5 稳定性

用数组实现的选择排序是不稳定的，用链表实现的选择排序是稳定的。不过，一般提到排序算法时，大家往往会默认是数组实现，所以选择排序是不稳定的。

## 2.6 适用场景

由于在各种情况下复杂度波动小，因此一般是优于冒泡排序的。在所有的完全交换排序中，选择排序也是比较不错的一种算法。但是，由于固有的O(n^2^)复杂度，选择排序在海量数据面前显得力不从心。因此，它适用于简单数据排序。



# 3. 插入排序(InsertionSort)

## 3.1 概念

插入排序(InsertionSort)，一般也被称为直接插入排序。

对于少量元素的排序，它是一个有效的算法。插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增 1 的有序表

在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。

## 3.2 算法描述

1. 把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的。
2. 从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置。
3. 重复上述过程直到最后一个元素被插入有序子数组中
==示意图==
[![](https://pic.imgdb.cn/item/60c5b18f844ef46bb239efcc.gif)](https://pic.imgdb.cn/item/60c5b18f844ef46bb239efcc.gif)


## 3.3 代码演示

```java
package com.zhuang.algorithm;

import java.util.Arrays;

/**
 * @Classname InsertionSort
 * @Description 插入排序
 * @Date 2021/6/13 15:20
 * @Created by dell
 */

public class InsertionSort {
    public static void main(String[] args) {
        int[] arr =new int[]{0,5,6,1,8,2};
        insertionSort(arr);
        System.out.println(Arrays.toString(arr));//[0, 1, 2, 5, 6, 8]
    }
    public static void insertionSort(int[] arr){
        //第二个元素开始遍历
        for (int i = 1; i < arr.length; i++) {
            int value = arr[i];
            int position=i;
            while (arr[position-1]>value){
                arr[position]=arr[position - 1];
                position--;
            }
            arr[position]=value;
        }
    }
}
```



## 3.4 算法分析

- 最佳情况：T(n) = O(n)
- 最坏情况：T(n) = O(n^2^)
- 平均情况：T(n) = O(n^2^)

## 3.5 稳定性

由于只需要找到不大于当前数的位置而并不需要交换，因此，直接插入排序是稳定的排序方法。

## 3.6 适用场景

插入排序由于O( n^2^ )的复杂度，在数组较大的时候不适用。但是，在数据比较少的时候，是一个不错的选择，一般做为快速排序的扩充。例如，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序。又如，在JDK 7 java.util.Arrays所用的sort方法的实现中，当待排数组长度小于47时，会使用插入排序。



# 4. 归并排序(MergeSort)

## 4.1 概念

归并排序利用的是分治的思想实现的，对于给定的一组数据，利用递归与分治技术将数据序列划分成为越来越小的子序列，之后对子序列排序，最后再用递归方法将排好序的子序列合并成为有序序列。合并两个子序列时，需要申请两个子序列加起来长度的内存，临时存储新的生成序列，再将新生成的序列赋值到原数组相应的位置。

## 4.2 算法描述

- 把长度为n的输入序列分成两个长度为n/2的子序列；
- 对这两个子序列分别采用归并排序；
- 将两个排序好的子序列合并成一个最终的排序序列。

==示意图==

![](https://pic.imgdb.cn/item/60c5f18a844ef46bb28ac56d.gif)

## 4.3 代码演示

```java
package com.zhuang.algorithm;

import java.util.Arrays;

/**
 * @Classname MergeSort
 * @Description 归并排序
 * @Date 2021/6/13 15:49
 * @Created by dell
 */


public class MergeSort {
    public static void main(String[] args) {
        int[] arr = {9, 2, 6, 3, 5, 7, 10, 11, 12};
        merSort(arr, 0, arr.length - 1);
        System.out.println(Arrays.toString(arr));//[2, 3, 5, 6, 7, 9, 10, 11, 12]
    }

    public static void merSort(int[] arr, int left, int right) {

        if (left < right) {
            int mid = (left + right) / 2;
            //左边归并排序，使得左子序列有序
            merSort(arr, left, mid);
            //右边归并排序，使得右子序列有序
            merSort(arr, mid + 1, right);
            //合并两个子序列
            merge(arr, left, mid, right);
        }
    }

    private static void merge(int[] arr, int left, int mid, int right) {
        //可以从开始就申请一个与原数组大小相同的数组，因为重复new数组会频繁申请内存
        int[] temp = new int[right - left + 1];
        int i = left;
        int j = mid + 1;
        int k = 0;
        while (i <= mid && j <= right) {
            if (arr[i] < arr[j]) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
            }
        }
        while (i <= mid) {
            //将左边剩余元素填充进temp中
            temp[k++] = arr[i++];
        }
        while (j <= right) {
            //将右序列剩余元素填充进temp中
            temp[k++] = arr[j++];
        }
        //将temp中的元素全部拷贝到原数组中
        for (int k2 = 0; k2 < temp.length; k2++) {
            arr[k2 + left] = temp[k2];
        }
    }
}
```

## 4.4 算法分析

- 最佳情况：T(n) = O(n)  
- 最差情况：T(n) = O(nlog^n^)  
- 平均情况：T(n) = O(nlog^n^)

## 4.5 适用场景

归并排序在数据量比较大的时候也有较为出色的表现（效率上），其空间复杂度O(n)使得在数据量特别大的时候（例如，1千万数据）几乎不可接受。而且，考虑到有的机器内存本身就比较小，因此，采用归并排序一定要注意。

# 5. 快速排序(QuickSort)

## 5.1 概念

快速排序主要采用分治的基本思想，每次将一个位置上的数据归位，此时该数左边的所有数据都比该数小，右边所有的数据都比该数大，然后递归将已归位的数据左右两边再次进行快排，从而实现所有数据的归位。

## 5.2 算法描述

1. 从数列中挑出一个元素，称为"基准"（temp），
2. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
3. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。
==示意图:==

[![](https://pic.imgdb.cn/item/60c5c13b844ef46bb24bfd16.gif)](https://pic.imgdb.cn/item/60c5c13b844ef46bb24bfd16.gif)

## 5.3 代码演示

```java
package com.zhuang.algorithm;

import java.util.Arrays;

/**
 * @Classname QuickSort
 * @Description 快速排序
 * @Date 2021/6/13 16:21
 * @Created by dell
 */

public class QuickSort {
    public static void main(String[] args) {
        int[] arr = {5, 2, 4, 8, 1, 9, 3, 15};
        quickSort(arr, 0, arr.length - 1);
        System.out.println(Arrays.toString(arr));
    }
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            //将数组分为两部分
            int index = getIndex(arr, low, high);
            //递归排序左子数组
            quickSort(arr, low, index - 1);
            //递归排序右子数组
            quickSort(arr, index + 1, high);
        }
    }

    public static int getIndex(int[] arr, int low, int high) {
        //基准temp
        int temp = arr[low];
        while (low < high) {
            while (low < high && arr[high] >= temp) {
                high--;
            }
            //交换比基准大的记录到左端
            arr[low] = arr[high];
            while (low < high && arr[low] <= temp) {
                low++;
            }
            //交换比基准小的记录到右端
            arr[high] = arr[low];
        }
        //扫描完成，基准到位
        arr[low] = temp;
        // 返回基准的位置
        return low;
    }

}
```

## 5.4 算法分析

- 最佳情况：T(n) = O(nlog^n^)  
- 最差情况：T(n) = O(n^2^)  
- 平均情况：T(n) = O(nlog^n^)

## 5.5 稳定性

快速排序并不是稳定的。这是因为我们无法保证相等的数据按顺序被扫描到和按顺序存放。

## 5.6 适用场景

快速排序在大多数情况下都是适用的，尤其在数据量大的时候性能优越性更加明显。但是在必要的时候，需要考虑下优化以提高其在最坏情况下的性能



# 6. 堆排序(HeapSort)

## 6.1 概念

堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。

## 6.2 堆的概念

堆是一种特殊的完全二叉树（complete binary tree）。完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。

![](https://pic.imgdb.cn/item/60c5d5d0844ef46bb26ebb66.png)

> 数组索引：  1     2    3    4   5   6   7   8   9   10
>
> 节点的值：  16  14  10   8   7   9  3    2   4    1   

已知父节点的下标为`i`，可以知道

- 左子节点的下标=`2*i`
- 右子节点的下标=`2*i+1`

已知节点下标为 j

- 父节点的下标=`(j-1)/2`



二叉堆一般分为两种：最大堆和最小堆。
**最大堆：**
最大堆中的最大元素值出现在根结点（堆顶）
堆中每个父节点的元素值都大于等于其孩子结点（如果存在）

![](https://pic.imgdb.cn/item/60c5d860844ef46bb28d10f8.png)

**最小堆：**
最小堆中的最小元素值出现在根结点（堆顶）
堆中每个父节点的元素值都小于等于其孩子结点（如果存在）

![](https://pic.imgdb.cn/item/60c5d860844ef46bb28d1109.png)

## 6.3 算法描述

堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作：

- 最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点
- 创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆
- 堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算 继续进行下面的讨论前，需要注意的一个问题是：数组都是 Zero-Based，这就意味着我们的堆数据结构模型要发生改变

![](https://pic.imgdb.cn/item/60c5d92b844ef46bb29649df.png)

前面的方法做出改变

> 数组索引：  0     1    2    3   4   5   6   7   8    9
>
> 节点的值：  16  14  10   8   7   9  3    2   4    1   

已知父节点的下标为`i`，可以知道

- 左子节点的下标=`2*i+1`
- 右子节点的下标=`2*i+2`

==示意图==

![](https://pic.imgdb.cn/item/60c5d9af844ef46bb29bec56.gif)

## 6.4 代码演示

```java
package com.zhuang.algorithm;

import java.util.Arrays;

/**
 * @Classname HeapSort
 * @Description 堆排序
 * @Date 2021/6/13 17:09
 * @Created by dell
 */

public class HeapSort {
    public static void main(String[] args) {
        int[] arr = {51, 46, 20, 18, 65, 97, 82, 30, 77, 50};
        heapSort(arr);
        System.out.println("堆排序以后的序列为:");
        System.out.println(Arrays.toString(arr));
    }
    //定义堆排序的方法

    /**
     * @param arr 数组
     */
    public static void heapSort(int[] arr) {
        int temp = 0;
        for (int i = arr.length / 2 - 1; i >= 0; i--) {
            adjustHeap(arr, i, arr.length);
        }
        //经过第一次调整 此时最大值位于大顶堆的根节点
        for (int j = arr.length - 1; j >= 1; j--) {
            temp = arr[j];
            arr[j] = arr[0];
            arr[0] = temp;
            System.out.println(Arrays.toString(arr));
            //递归进行大顶堆的下次调整
            //此时从根节点 i=0开始
            adjustHeap(arr, 0, j);
        }
    }
    //定义将处于i位置的子树调整成大顶堆的方法

    /**
     * @param arr 待排序的数组
     * @param i   非叶子子节点
     * @param len 构建大顶堆的数组参与的元素的长度
     */
    public static void adjustHeap(int[] arr, int i, int len) {
        //定义临时变量
        int temp = arr[i];
        // 由于数组下标为0，则若i为某个非叶子节点，左子节点为i*2+1;右子节点为i*2+2
        // 构建大顶堆从左到右，自下往上进行
        //下次继续选择该节点的左子节点
        for (int k = i * 2 + 1; k < len; k = k * 2 + 1) {
            //在未越界的情况下，在未越界的情况下:如果当前非叶子节点的左子节点的值小于右子节点的值,则选择最大值,成为新的非叶子父节点
            if (k + 1 < len && arr[k] < arr[k + 1]) {
                //选择右子节点
                k += 1;
            }
            //进行比较出的左右子节点的最大值和当前父节点的大小进行比较，完成大顶堆
            if (arr[k] > temp) {
                //将arr[i]设置为最大值
                arr[i] = arr[k];
                //将i置为k,即下一轮int temp = arr[i] = arr[k],继续循环比较
                i = k;
            } else {
                break;
            }
        }
        //for循环后，将以i为父节点的最大值放在顶部
        arr[i] = temp;
    }
}
```

```java
[50, 77, 82, 46, 65, 20, 51, 30, 18, 97]
[18, 77, 51, 46, 65, 20, 50, 30, 82, 97]
[30, 65, 51, 46, 18, 20, 50, 77, 82, 97]
[50, 46, 51, 30, 18, 20, 65, 77, 82, 97]
[20, 46, 50, 30, 18, 51, 65, 77, 82, 97]
[18, 46, 20, 30, 50, 51, 65, 77, 82, 97]
[18, 30, 20, 46, 50, 51, 65, 77, 82, 97]
[20, 18, 30, 46, 50, 51, 65, 77, 82, 97]
[18, 20, 30, 46, 50, 51, 65, 77, 82, 97]
堆排序以后的序列为:
[18, 20, 30, 46, 50, 51, 65, 77, 82, 97]
```

## 6.5 算法分析

- 最佳情况：T(n) = O(nlog^n^) 

- 最差情况：T(n) = O(nlog^n^) 
- 平均情况：T(n) = O(nlog^n^)

## 6.6 稳定性

堆排序存在大量的筛选和移动过程，属于不稳定的排序算法。

## 6.7 适用场景

堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用。但是，在元素比较多的情况下，还是不错的一个选择。尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。



# 7. 希尔排序(ShellSort)

## 7.1 概念

希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。

希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。



## 7.2 算法描述

我们来看下希尔排序的基本步骤，在此我们选择增量`gap=length/2`，缩小增量继续以`gap = gap/2`的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2...1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。

先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：

- 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
- 按增量序列个数k，对序列进行k 趟排序；
- 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。



==示意图==

参考文章：[十大经典排序算法](https://blog.csdn.net/qq_20198973/article/details/79679956?ops_request_misc=&request_id=&biz_id=102&utm_term=排序算法java&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-.nonecase&spm=1018.2226.3001.4187)

![](https://pic.imgdb.cn/item/60c5defd844ef46bb2d0f231.png)

## 7.3 代码演示

```java
package com.zhuang.algorithm;

import java.util.Arrays;

/**
 * @Classname ShellSort
 * @Description 希尔排序
 * @Date 2021/6/13 18:23
 * @Created by dell
 */

public class ShellSort {
    public static void main(String[] args) {
        int[] arr = {51, 46, 20, 18, 65, 97, 82, 30, 77, 50};
        shellsort(arr);
        System.out.println("希尔排序以后的序列为:");
        System.out.println(Arrays.toString(arr));//[18, 20, 30, 46, 50, 51, 65, 77, 82, 97]
    }

    public static void shellsort(int[] array) {
        int len = array.length;
        int temp, gap = len / 2;
        while (gap > 0) {
            for (int i = gap; i < len; i++) {
                temp = array[i];
                int preIndex = i - gap;
                while (preIndex >= 0 && array[preIndex] > temp) {
                    array[preIndex + gap] = array[preIndex];
                    preIndex -= gap;
                }
                array[preIndex + gap] = temp;
            }
            gap /= 2;
        }
    }
}
```

## 7.4 算法分析

- 最佳情况：T(n) = O(nlog~2~^n^) 
- 最坏情况：T(n) = O(nlog~2~^n^)  
- 平均情况：T(n) =O(nlog~2~^n^)　

## 7.5 稳定性

我们都知道插入排序是稳定算法。但是，Shell排序是一个多次插入的过程。在一次插入中我们能确保不移动相同元素的顺序，但在多次的插入中，相同元素完全有可能在不同的插入轮次被移动，最后稳定性被破坏，因此，Shell排序不是一个稳定的算法。

## 7.6 适用场景

Shell排序虽然快，在大量数据面前，Shell排序不是一个好的算法。但是，中小型规模的数据完全可以使用它。

# 8. 计数排序(CountSort)

## 8.1 概念

计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。



## 8.2 算法描述

- 找出待排序的数组中最大和最小的元素
- 统计数组中每个值为i的元素出现的次数，存入数组C的第i项
- 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加
- 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1

==示意图==

![](https://pic.imgdb.cn/item/60c5e387844ef46bb2fda24e.gif)



## 8.3 代码演示

```java
package com.zhuang.algorithm;

import java.util.Arrays;

/**
 * @Classname CountSort
 * @Description 计数排序
 * @Date 2021/6/13 18:46
 * @Created by dell
 */

public class CountSort {
    public static void main(String[] args) {
        int[] arr = {51, 46, 20, 18, 0, 97, 82, 30, 77, 50};
        countSort(arr);
        System.out.println("计数排序以后的序列为:");
        System.out.println(Arrays.toString(arr));//[0, 18, 20, 30, 46, 50, 51, 77, 82, 97]
    }

    public static void countSort(int[] arr) {
        //找出数组中的最大值
        int max = arr[0];
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        //初始化计数数组
        int[] countArray = new int[max + 1];

        //计数
        for (int i = 0; i < arr.length; i++) {
            countArray[arr[i]]++;
            arr[i] = 0;
        }
        //排序
        int index = 0;
        for (int i = 0; i < countArray.length; i++) {
            if (countArray[i] > 0) {
                arr[index++] = i;
            }
        }
    }
}
```

## 8.4 算法分析

当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。

- 最佳情况：T(n) = O(n+k)  
- 最差情况：T(n) = O(n+k)  
- 平均情况：T(n) = O(n+k)



## 8.5 适用场景

计数排序需要占用大量空间，它比较适用于数据比较集中的情况





# 9. 桶排序(BucketSort)

## 9.1 概念

桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。

桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排

## 9.2 算法描述

- 设置一个定量的数组当作空桶子。
- 寻访序列，并且把项目一个一个放到对应的桶子去。
- 对每个不是空的桶子进行排序。
- 从不是空的桶子里把项目再放回原来的序列中。

==示意图==

![](https://pic.imgdb.cn/item/60c5e602844ef46bb215dc6a.gif)

## 9.3 代码演示

```java
package com.zhuang.algorithm;

import java.util.ArrayList;
import java.util.*;

/**
 * @Classname BucketSort
 * @Description 桶排序
 * @Date 2021/6/13 19:07
 * @Created by dell
 */

public class BucketSort {
    public static void main(String[] args) {
        int[] arr = {51, 46, 20, 18, 65, 97, 82, 30, 77, 50};
        bucketSort(arr);
        System.out.println("桶排序以后的序列为:");
        System.out.println(Arrays.toString(arr));
    }

    public static void bucketSort(int[] arr) {
        //最大最小值
        int max = arr[0];
        int min = arr[0];
        int len = arr.length;

        for (int i = 0; i < len; i++) {
            if (arr[i] > max) {
                max = arr[i];
            } else if (arr[i] < min) {
                max = arr[i];
            }
        }
        //最大值和最小值得差
        int diff = max - min;

        //桶列表
        ArrayList<ArrayList<Integer>> list = new ArrayList<>();
        for (int i = 0; i < len; i++) {
            list.add(new ArrayList<>());
        }

        //每个桶的存数区间
        float section = (float) diff / (float) (len - 1);

        //数据入桶
        for (int i = 0; i < len; i++) {
            //当前数除以区间得出存放桶的位置，减1得出桶的下标
            int num = (int) ((arr[i] / section) - 1);
            if (num < 0) {
                num = 0;
            }
            list.get(num).add(arr[i]);
        }
        //桶内排序
        for (int i = 0; i < list.size(); i++) {
            Collections.sort(list.get(i));
        }
        //写入原数组
        int index = 0;
        for (ArrayList<Integer> arrayList : list) {
            for (Integer integer : arrayList) {
                arr[index] = integer;
                index++;
            }
        }
    }
}
```

**或者下列方法也可以**

```java
package com.zhuang.algorithm;

import java.util.ArrayList;
import java.util.*;

/**
 * @Classname BucketSort
 * @Description 桶排序
 * @Date 2021/6/13 19:07
 * @Created by dell
 */

public class BucketSort {
    public static void main(String[] args) {
        int[] arr = {51, 46, 20, 18, 65, 97, 82, 30, 77, 50};
        bucketSort(arr);
    }

    public static void bucketSort(int[] arr) {
        int max = Integer.MIN_VALUE;
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < arr.length; i++) {
            max = Math.max(max, arr[i]);
            min = Math.min(min, arr[i]);
        }
        //桶数
        int bucketNum = (max - min) / arr.length + 1;
        ArrayList<ArrayList<Integer>> bucketArr = new ArrayList<>(bucketNum);
        for (int i = 0; i < bucketNum; i++) {
            bucketArr.add(new ArrayList<Integer>());
        }
        //将每个元素放入桶
        for (int i = 0; i < arr.length; i++) {
            int num = (arr[i] - min) / (arr.length);
            bucketArr.get(num).add(arr[i]);
        }
        //对每个桶进行排序
        for (int i = 0; i < bucketArr.size(); i++) {
            Collections.sort(bucketArr.get(i));
        }
        System.out.println(bucketArr.toString());
    }
}
```

## 9.4 算法分析

桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大

## 9.5 适用场景

桶排序可用于最大最小值相差较大的数据情况，但桶排序要求数据的分布必须均匀，否则可能导致数据都集中到一个桶中



# 10. 基数排序(RadixSort)

## 10.1 概念

基数排序(Radix Sort)是桶排序的扩展，它的基本思想是：将整数按位数切割成不同的数字，然后按每个位数分别比较。
排序过程：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列

## 10.2 算法描述

1. 取得数组中的最大数，并取得位数
2. arr为原始数组，从最低位开始取每个位组成radix数组
3. 对radix进行计数排序（利用计数排序适用于小范围数的特点）

![](https://pic.imgdb.cn/item/60c5ebca844ef46bb250812f.gif)



## 10.3 代码演示

```java
package com.zhuang.algorithm;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * @Classname RadixSort
 * @Description 基数排序
 * @Date 2021/6/13 19:31
 * @Created by dell
 */

public class RadixSort {
    public static void main(String[] args) {
        int[] arr = {51, 46, 20, 18, 65, 97, 82, 30, 77, 50};
        radixSort(arr);
        System.out.println("基数排序以后的序列为:");
        System.out.println(Arrays.toString(arr));//[18, 20, 30, 46, 50, 51, 65, 77, 82, 97]
    }
    public static void radixSort(int[] arr) {
        int max = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        int time = 0;
        while (max > 0) {
            max /= 10;
            time++;
        }
        List<ArrayList<Integer>> queue = new ArrayList<ArrayList<Integer>>();
        for (int i = 0; i < 10; i++) {
            ArrayList<Integer> queue1 = new ArrayList<Integer>();
            queue.add(queue1);
        }
        for (int i = 0; i < time; i++) {
            for (int j = 0; j < arr.length; j++) {
                int x = arr[j] % (int) Math.pow(10, i + 1) / (int) Math.pow(10, i);
                ArrayList<Integer> queue2 = queue.get(x);
                queue2.add(arr[j]);
                queue.set(x, queue2);
            }
            int count = 0;
            for (int k = 0; k < 10; k++) {
                while (queue.get(k).size() > 0) {
                    ArrayList<Integer> queue3 = queue.get(k);
                    arr[count] = queue3.get(0);
                    queue3.remove(0);
                    count++;
                }
            }
        }
    }
}
```

## 10.4 适用场景

基数排序要求较高，元素必须是整数，整数时长度10W以上，最大值100W以下效率较好，但是基数排序比其他排序好在可以适用字符串



